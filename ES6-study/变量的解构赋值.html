<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>变量的解构赋值</title>
</head>
<body>

    <script>

        // 变量的解构赋值用途：
            // 交换变量的值
            // 从函数返回多个值
            // 函数参数的定义
            // 提取JSON数据
            // 函数参数的默认值
            // 遍历Map结构
            // 输入模块的指定方法

    // 数组的解构赋值 ----------------------------------------------------------------------
        // -------- 基本 --------
        let [a, b, c] = [1, 2, 3];
        // 从数组中提取值，按照对应位置，对变量赋值
        // 只要等号两边的模式相同，左边的变量就会被赋予对应的值。

        // 解构不成功，变量的值就等于undefined
        let [x, y] = [1, 2, 3];
        x // 1
        y // 2

        let [a, [b], d] = [1, [2, 3], 4];
        a // 1
        b // 2
        d // 4
        // 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
        // 如果等号的右边不是数组（不是可遍历的结构），那么将会报错。

        // -------- 默认值 --------
        let [foo = true] = [];
        foo // true

        let [x, y = 'b'] = ['a']; // x='a', y='b'
        let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
        // 解构赋值允许指定默认值。
        // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明


    // 对象的解构赋值 ----------------------------------------------------------------------
        let { foo, bar } = { foo: "aaa", bar: "bbb" };
        foo // "aaa"
        bar // "bbb"
        // 对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

        let { foo: baz } = { foo: "aaa", bar: "bbb" };
        baz // "aaa"
        foo // error: foo is not defined
        // 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

        let obj = {
            p: [
                'Hello',
                { y: 'World' }
            ]
        };

        let { p: [x, { y }] } = obj;
        x // "Hello"
        y // "World"

        var node = {
            loc: {
                start: {
                line: 1,
                column: 5
                }
            }
        };
        var { loc: { start: { line }} } = node;
        line // 1
        loc  // error: loc is undefined
        start // error: start is undefined
        // 解构也可以用于嵌套结构的对象

        var {x = 3} = {};
        x // 3

        var {x, y = 5} = {x: 1};
        x // 1
        y // 5

        var {x:y = 3} = {};
        y // 3

        var {x:y = 3} = {x: 5};
        y // 5
        // 对象的解构也可以指定默认值。



    // 字符串的解构赋值 ----------------------------------------------------------------------
        const [a, b, c, d, e] = 'hello';
        a // "h"
        b // "e"
        c // "l"
        d // "l"
        e // "o"

    // 数值和布尔值的解构赋值 -----------------------------------------------------------------
        let {toString: s} = 123;
        s === Number.prototype.toString // true

        let {toString: s} = true;
        s === Boolean.prototype.toString // true
        // 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

    // 函数参数的解构赋值 --------------------------------------------------------------------
        function add([x, y]){
            return x + y;
        }
        add([1, 2]); // 3

        [[1, 2], [3, 4]].map(([a, b]) => a + b);
        // [ 3, 7 ]
        // 参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。

        function move({x = 0, y = 0} = {}) {
            return [x, y];
        }
        move({x: 3, y: 8}); // [3, 8]
        move({x: 3}); // [3, 0]
        move({}); // [0, 0]
        move(); // [0, 0]
        // 函数参数的解构也可以使用默认值
    </script>
    
</body>
</html>